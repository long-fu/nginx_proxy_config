
# =========================
# Nginx 主进程 & worker 配置
# =========================

# worker 进程数，auto = CPU 核心数
# 高并发场景下，1 个 CPU 核心 ≈ 1 个 worker 是最优解
worker_processes auto;

# =========================
# 事件模型（连接处理）
# =========================
events {
    # Linux 下高并发首选 epoll
    use epoll;

    # 单个 worker 允许的最大并发连接数
    # 实际最大并发 ≈ worker_processes × worker_connections
    worker_connections 65535;

    # 尽可能一次 accept 更多连接，减少惊群
    multi_accept on;
}

# =========================
# HTTP 核心配置
# =========================
http {

    # =========================
    # TCP / IO 性能优化
    # =========================

    # 启用 sendfile，实现 0 拷贝（静态文件性能提升明显）
    sendfile on;

    # 响应头一次性发送，减少 TCP 包数量
    tcp_nopush on;

    # 小数据包立即发送，降低延迟（API 场景很重要）
    tcp_nodelay on;

    # =========================
    # KeepAlive（高并发核心）
    # =========================

    # HTTP keepalive 超时时间
    keepalive_timeout 65;

    # 单连接最大请求数
    # 防止长连接被无限占用
    keepalive_requests 100000;

    # =========================
    # 客户端请求缓冲区
    # =========================

    # 请求体缓冲大小（POST / PUT）
    client_body_buffer_size 128k;

    # 最大请求体大小（防止 413）
    client_max_body_size 100m;

    # 普通 header buffer
    client_header_buffer_size 8k;

    # 大 header buffer（防止 400 Bad Request）
    large_client_header_buffers 4 32k;

    # =========================
    # 反向代理 Buffer（防磁盘 IO）
    # =========================

    # 启用代理缓冲
    proxy_buffering on;

    # 后端响应 buffer 数量和大小
    proxy_buffers 64 16k;

    # 单个 buffer 大小（一般 >= header）
    proxy_buffer_size 32k;

    # 忙碌 buffer 大小
    proxy_busy_buffers_size 64k;

    # 禁止代理响应写入临时文件（高并发关键）
    proxy_max_temp_file_size 0;

    # =========================
    # 反向代理超时设置
    # =========================

    # 与后端建立连接的超时时间
    proxy_connect_timeout 5s;

    # 向后端发送请求的超时时间
    proxy_send_timeout 60s;

    # 等待后端响应的超时时间
    proxy_read_timeout 60s;

    # =========================
    # 限流 & 限连接（生产必备）
    # =========================

    # 按客户端 IP 限制并发连接数
    limit_conn_zone $binary_remote_addr zone=conn_limit:10m;

    # 按客户端 IP 限制请求速率
    # rate=100r/s 表示每秒 100 个请求
    limit_req_zone $binary_remote_addr zone=req_limit:10m rate=100r/s;

    # =========================
    # upstream（后端连接池）
    # =========================
    upstream backend {
        # 后端服务地址
        server 127.0.0.1:8080;

        # 与后端保持的长连接数量
        # 高并发时可极大减少 TCP 建连开销
        keepalive 1024;
    }

    # =========================
    # Server 配置（反向代理入口）
    # =========================
    server {
        # 监听端口
        listen 80;

        # =========================
        # 日志（压测或高并发可关闭）
        # =========================
        # access_log off;

        location / {

            # 单 IP 最大并发连接数
            limit_conn conn_limit 100;

            # 请求速率限制
            # burst=200：允许瞬时突发
            # nodelay：不延迟直接拒绝
            limit_req zone=req_limit burst=200 nodelay;

            # =========================
            # 反向代理核心配置
            # =========================

            # 使用 HTTP/1.1（keepalive 必须）
            proxy_http_version 1.1;

            # 清除 Connection 头，启用 upstream keepalive
            proxy_set_header Connection "";

            # 保留 Host 头（对虚拟主机很重要）
            proxy_set_header Host $host;

            # 客户端真实 IP
            proxy_set_header X-Real-IP $remote_addr;

            # 代理链 IP
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            # 协议标识（HTTP / HTTPS）
            proxy_set_header X-Forwarded-Proto $scheme;

            # 转发到 upstream
            proxy_pass http://backend;
        }
    }
}
